# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: lacss.proto
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x0blacss.proto\x12\x0ftrackmate.lacss\"l\n\x05Image\x12\x0e\n\x06height\x18\x01 \x01(\x04\x12\r\n\x05width\x18\x02 \x01(\x04\x12\x0f\n\x07\x63hannel\x18\x03 \x01(\x04\x12%\n\x05\x64type\x18\x04 \x01(\x0e\x32\x16.trackmate.lacss.DType\x12\x0c\n\x04\x64\x61ta\x18\x05 \x01(\x0c\"5\n\x06Result\x12\x0e\n\x06height\x18\x01 \x01(\x04\x12\r\n\x05width\x18\x02 \x01(\x04\x12\x0c\n\x04\x64\x61ta\x18\x06 \x01(\x0c\"\x9d\x01\n\x08Settings\x12\x15\n\rmin_cell_area\x18\x01 \x01(\x02\x12\x1b\n\x13remove_out_of_bound\x18\x02 \x01(\x08\x12\x0f\n\x07scaling\x18\x03 \x01(\x02\x12\x0f\n\x07nms_iou\x18\x04 \x01(\x02\x12\x1b\n\x13\x64\x65tection_threshold\x18\x05 \x01(\x02\x12\x1e\n\x16segmentation_threshold\x18\x06 \x01(\x02\"[\n\x05Input\x12+\n\x08settings\x18\x01 \x01(\x0b\x32\x19.trackmate.lacss.Settings\x12%\n\x05image\x18\x02 \x01(\x0b\x32\x16.trackmate.lacss.Image*\x14\n\x05\x44Type\x12\x0b\n\x07\x46LOAT32\x10\x00\x42\'\n\x1b\x66iji.plugin.trackmate.lacssB\x08LacssMsgb\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'lacss_pb2', _globals)
if _descriptor._USE_C_DESCRIPTORS == False:
  _globals['DESCRIPTOR']._options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\033fiji.plugin.trackmate.lacssB\010LacssMsg'
  _globals['_DTYPE']._serialized_start=450
  _globals['_DTYPE']._serialized_end=470
  _globals['_IMAGE']._serialized_start=32
  _globals['_IMAGE']._serialized_end=140
  _globals['_RESULT']._serialized_start=142
  _globals['_RESULT']._serialized_end=195
  _globals['_SETTINGS']._serialized_start=198
  _globals['_SETTINGS']._serialized_end=355
  _globals['_INPUT']._serialized_start=357
  _globals['_INPUT']._serialized_end=448
# @@protoc_insertion_point(module_scope)


from pathlib import Path
import sys
import struct
import zipfile

import jax.numpy as jnp
import imageio.v2 as imageio

import lacss.deploy
from lacss.ops import patches_to_label
# import lacss_pb2 as LacssMsg
import numpy as np
import typer


app = typer.Typer(pretty_exceptions_enable=False)

def _make_label_continous(m):
    m = m.astype(int)

    k = np.unique(m)
    v = np.asarray(range(len(k)))

    mapping_ar = np.zeros(k.max() + 1, dtype=int)
    mapping_ar[k] = v

    return mapping_ar[m]

def read_input(st = sys.stdin.buffer):
    msg_size = st.read(4)
    msg_size = struct.unpack(">i", msg_size)[0]

    msg = Input()
    msg.ParseFromString(st.read(msg_size))

    image = msg.image
    np_img = np.frombuffer(image.data, dtype=">f4").astype("float32")
    np_img = np_img.reshape(image.channel, image.width, image.height)
    np_img = np_img.transpose(2, 1, 0)

    return np_img, msg.settings

def write_result(label, st = sys.stdout.buffer):
    if len(label.shape) != 2 :
        raise ValueError(f"Expect 2D array as label. Got array of {label.shape}")

    label = np.ascontiguousarray(label, dtype=">i2") # match java format

    msg = Result()
    msg.height = label.shape[0]
    msg.width = label.shape[1]
    msg.data = label.tobytes()

    assert len(msg.data) == msg.height * msg.width * 2

    msg_size_bits = struct.pack(">i", msg.ByteSize())

    st.write(msg_size_bits)
    st.write(msg.SerializeToString())

@app.command()
def main(modelpath: Path):
    modelpath = str(modelpath)
    if "!" in modelpath: # in a jar
        jarfile, rscpath = modelpath.split("!")
        with zipfile(jarfile, "r") as jar:
            with jar.open(rscpath) as modelfile:
                import pickle
                modelpath = pickle.load(modelfile)

    model = lacss.deploy.Predictor(modelpath)
    model.detector.test_max_output = 512

    # cnt = 0

    while True:
        img, settings = read_input()
        img = img - img.min()
        img = img / img.max()

        print(f"received image {img.shape}", file=sys.stderr)

        preds = model.predict(
            img, 
            min_area=settings.min_cell_area,
            remove_out_of_bound=settings.remove_out_of_bound,
            scaling=settings.scaling,
        )

        label = patches_to_label(
            preds, 
            input_size=img.shape[:2],
            score_threshold=settings.detection_threshold,
            threshold=settings.segmentation_threshold,
        )

        label = _make_label_continous(label)
        
        write_result(label.transpose())

        # imageio.imwrite(f"p_{cnt}.tif", np.asarray(label))
        # cnt+=1

if __name__ == "__main__":
    app()
